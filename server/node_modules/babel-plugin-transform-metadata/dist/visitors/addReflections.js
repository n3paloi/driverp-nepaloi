"use strict";

exports.__esModule = true;
exports.default = void 0;
var addReflections = {
  TypeCastExpression: function TypeCastExpression(path, _ref) {
    var magicTypeCasts = _ref.magicTypeCasts,
        magicTypeCastExpression = _ref.magicTypeCastExpression;

    if (path.node.expression.name === magicTypeCastExpression) {
      magicTypeCasts.push(path);
    }
  },
  'ClassDeclaration|FunctionDeclaration|FunctionExpression|ArrowFunctionExpression': function ClassDeclarationFunctionDeclarationFunctionExpressionArrowFunctionExpression(path, _ref2) {
    var onlyExports = _ref2.onlyExports,
        parentPaths = _ref2.parentPaths,
        exportNames = _ref2.exportNames;
    var node = path.node;
    var parent = path.parent;
    var ref;
    var insertPath;

    switch (parent.type) {
      case 'ExportDefaultDeclaration':
      case 'ExportNamedDeclaration':
        insertPath = path.parentPath;
        ref = node.id;
        break;

      case 'VariableDeclarator':
        insertPath = path.parentPath.parentPath;
        ref = parent.id;
        break;

      case 'Program':
        insertPath = path;
        ref = node.id;
        break;

      default:
        ref = null;
        insertPath = null;
    }

    if (!insertPath) {
      return;
    }

    if (onlyExports && !exportNames.has(ref.name)) {
      return;
    }

    var params;

    if (node.type === 'ClassDeclaration') {
      var body = node.body.body;

      for (var i = 0; i < body.length; i++) {
        var bodyNode = body[i];

        if (bodyNode.type === 'ClassMethod' && bodyNode.kind === 'constructor') {
          params = bodyNode.params;
          break;
        } else if (bodyNode.type === 'ClassProperty') {// @todo parameters from props
        }
      }
    } else {
      params = node.params;
    } // if (params)


    {
      parentPaths.push([insertPath, params, ref, node]);
    }
  }
};
var _default = addReflections;
exports.default = _default;
//# sourceMappingURL=addReflections.js.map