{"version":3,"sources":["../../src/metaCreators/createInjectParamTypes.js"],"names":["createInjectParamTypes","t","injectPrefixRaw","typeForAnnotations","functionsWithJsx","filename","addDisplayName","injectPrefix","identifier","displayNameId","injectParamTypes","rawTypes","target","node","body","type","isJsx","has","meta","typeArgs","length","types","slice","typeParameters","params","isFunction","push","numericLiteral","arrayExpression","expressionStatement","assignmentExpression","memberExpression","stringLiteral","name"],"mappings":";;;;;AAAe,SAASA,sBAAT,CACXC,CADW,EAEXC,eAFW,EAGXC,kBAHW,EAIXC,gBAJW,EAKXC,QALW,EAMXC,cANW,EAOb;AACE,MAAMC,eAAeN,EAAEO,UAAF,CAAaN,mBAAmB,IAAhC,CAArB;AACA,MAAMO,gBAAgBR,EAAEO,UAAF,CAAa,aAAb,CAAtB;AAEA,SAAO,SAASE,gBAAT,CAA0BC,QAA1B,EAAoCC,MAApC,EAA4CC,IAA5C,EAAkD;AACrD,QAAMC,OAAO,EAAb;AACA,QAAMC,OAAOF,KAAKE,IAAlB;AACA,QAAMC,QAAQZ,iBAAiBa,GAAjB,CAAqBJ,IAArB,CAAd;AACA,QAAMK,OAAO,EAAb;AAEA,QAAIC,WAAW,EAAf;;AACA,QAAIR,YAAYA,SAASS,MAAzB,EAAiC;AAC7B,UAAIC,KAAJ;;AACA,UAAIL,KAAJ,EAAW;AACPK,gBAAQV,SAASW,KAAT,CAAe,CAAf,CAAR;AACH,OAFD,MAEO;AACHD,gBAAQV,QAAR;AACH;;AAEDQ,iBAAWhB,mBACPkB,KADO,EAEPR,KAAKU,cAAL,GAAsBV,KAAKU,cAAL,CAAoBC,MAA1C,GAAmD,IAF5C,CAAX;AAIH;;AAED,QAAMC,aAAaV,SAAS,qBAAT,IACZA,SAAS,oBADG,IAEZA,SAAS,yBAFhB;;AAIA,QAAII,SAASC,MAAb,EAAqB;AACjBF,WAAKQ,IAAL,CAAUzB,EAAE0B,cAAF,CAAiBX,QAAQ,CAAR,GAAaS,aAAa,CAAb,GAAiB,CAA/C,CAAV;AACAP,WAAKQ,IAAL,CAAUzB,EAAE2B,eAAF,CAAkBT,QAAlB,CAAV;AACH,KAHD,MAGO,IAAIM,UAAJ,EAAgB;AACnBP,WAAKQ,IAAL,CAAUzB,EAAE0B,cAAF,CAAiBX,QAAQ,CAAR,GAAY,CAA7B,CAAV;AACH;;AAED,QAAIV,cAAJ,EAAoB;AAChBQ,WAAKY,IAAL,CAAUzB,EAAE4B,mBAAF,CAAsB5B,EAAE6B,oBAAF,CAC5B,GAD4B,EAE5B7B,EAAE8B,gBAAF,CAAmBnB,MAAnB,EAA2BH,aAA3B,CAF4B,EAG5BR,EAAE+B,aAAF,CAAgB3B,WAAYA,WAAW,GAAX,GAAiBO,OAAOqB,IAApC,GAA4CrB,OAAOqB,IAAnE,CAH4B,CAAtB,CAAV;AAKH;;AAED,QAAIf,KAAKE,MAAT,EAAiB;AACbN,WAAKY,IAAL,CAAUzB,EAAE4B,mBAAF,CAAsB5B,EAAE6B,oBAAF,CAC5B,GAD4B,EAE5B7B,EAAE8B,gBAAF,CAAmBnB,MAAnB,EAA2BL,YAA3B,CAF4B,EAG5BN,EAAE2B,eAAF,CAAkBV,IAAlB,CAH4B,CAAtB,CAAV;AAKH;;AAGD,WAAOJ,IAAP;AACH,GAlDD;AAmDH","file":"createInjectParamTypes.js","sourcesContent":["export default function createInjectParamTypes(\n    t,\n    injectPrefixRaw,\n    typeForAnnotations,\n    functionsWithJsx,\n    filename,\n    addDisplayName\n) {\n    const injectPrefix = t.identifier(injectPrefixRaw || '_r')\n    const displayNameId = t.identifier('displayName')\n\n    return function injectParamTypes(rawTypes, target, node) {\n        const body = []\n        const type = node.type\n        const isJsx = functionsWithJsx.has(node)\n        const meta = []\n\n        let typeArgs = []\n        if (rawTypes && rawTypes.length) {\n            let types\n            if (isJsx) {\n                types = rawTypes.slice(1)\n            } else {\n                types = rawTypes\n            }\n\n            typeArgs = typeForAnnotations(\n                types,\n                node.typeParameters ? node.typeParameters.params : null\n            )\n        }\n\n        const isFunction = type === 'FunctionDeclaration'\n            || type === 'FunctionExpression'\n            || type === 'ArrowFunctionExpression'\n\n        if (typeArgs.length) {\n            meta.push(t.numericLiteral(isJsx ? 1 : (isFunction ? 2 : 0)))\n            meta.push(t.arrayExpression(typeArgs))\n        } else if (isFunction) {\n            meta.push(t.numericLiteral(isJsx ? 1 : 2))\n        }\n\n        if (addDisplayName) {\n            body.push(t.expressionStatement(t.assignmentExpression(\n                '=',\n                t.memberExpression(target, displayNameId),\n                t.stringLiteral(filename ? (filename + '#' + target.name) : target.name)\n            )))\n        }\n\n        if (meta.length) {\n            body.push(t.expressionStatement(t.assignmentExpression(\n                '=',\n                t.memberExpression(target, injectPrefix),\n                t.arrayExpression(meta)\n            )))\n        }\n\n\n        return body\n    }\n}\n"]}