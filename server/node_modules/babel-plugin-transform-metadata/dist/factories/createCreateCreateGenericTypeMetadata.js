"use strict";

exports.__esModule = true;
exports.default = createCreateCreateGenericTypeMetadata;

function createCreateCreateGenericTypeMetadata(t, externalTypeNames, internalTypes, markGenerics) {
  return function createCreateGenericTypeMetadata(createObjectTypeMetadata) {
    return function createGenericTypeMetadata(annotation, typeParameters) {
      if (annotation.type === 'TypeofTypeAnnotation') {
        return createGenericTypeMetadata(annotation.argument);
      }

      var id = annotation.id;

      if (typeParameters) {
        for (var i = 0; i < typeParameters.length; i++) {
          if (typeParameters[i].name === id.name) {
            return t.stringLiteral(id.name);
          }
        }
      }

      var tp = annotation.typeParameters;

      if (tp && tp.params && tp.params.length) {
        var param = tp.params[0];
        var result;

        switch (param.type) {
          case 'TypeofTypeAnnotation':
          case 'GenericTypeAnnotation':
            result = createGenericTypeMetadata(param);
            break;

          case 'UnionTypeAnnotation':
            result = param.types.map(function (par) {
              return createGenericTypeMetadata(par);
            });
            break;

          default:
            result = null;
        }

        if (result) {
          var interfaceId = markGenerics[id.name];
          return interfaceId ? t.arrayExpression([t.numericLiteral(interfaceId)].concat(Array.isArray(result) ? result : [result])) : result;
        }
      }

      var internalType = internalTypes.get(id.name);

      if (internalType) {
        return createObjectTypeMetadata(internalType);
      }

      if (externalTypeNames.has(id.name)) {
        var imported = externalTypeNames.get(id.name);
        return imported ? t.stringLiteral(imported) : t.nullLiteral();
      }

      return id;
    };
  };
}
//# sourceMappingURL=createCreateCreateGenericTypeMetadata.js.map