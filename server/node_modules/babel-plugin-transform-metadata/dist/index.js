"use strict";

exports.__esModule = true;
exports.default = babelPluginTransformMetadata;

var _path = require("path");

var _getTypesInfo = _interopRequireDefault(require("./visitors/getTypesInfo"));

var _addReflections = _interopRequireDefault(require("./visitors/addReflections"));

var _createTypeForAnnotation = _interopRequireDefault(require("./factories/createTypeForAnnotation"));

var _createCreateCreateGenericTypeMetadata = _interopRequireDefault(require("./factories/createCreateCreateGenericTypeMetadata"));

var _createCreateCreateObjectTypeMetadata = _interopRequireDefault(require("./factories/createCreateCreateObjectTypeMetadata"));

var _createTypeForAnnotations = _interopRequireDefault(require("./factories/createTypeForAnnotations"));

var _createGetUniqueTypeName = _interopRequireDefault(require("./factories/createGetUniqueTypeName"));

var _createParentPathInsertAfter = _interopRequireDefault(require("./modifiers/createParentPathInsertAfter"));

var _createReplaceMagicTypeCasts = _interopRequireDefault(require("./modifiers/createReplaceMagicTypeCasts"));

var _createInjectParamTypes = _interopRequireDefault(require("./metaCreators/createInjectParamTypes"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }

var defaults = {
  typeNameStrategy: 'typeName',
  markGenerics: {
    'ISource': 1,
    'IStatus': 2
  },
  onlyExports: false,
  addFileName: false,
  addDisplayName: false,
  injectPrefix: '_r',
  ambiantTypeCastImport: 'babel-plugin-transform-metadata/_',
  ambiantDepsImport: 'babel-plugin-transform-metadata/Deps'
};

function babelPluginTransformMetadata(_ref) {
  var t = _ref.types;
  var cnf;
  return {
    visitor: {
      Program: function Program(path, _ref2) {
        var opts = _ref2.opts,
            file = _ref2.file;

        if (!cnf) {
          cnf = _extends({}, defaults, opts);
        }

        var prefix = process ? process.cwd() : '';
        var filename = !cnf.addFileName || file.opts.filename === 'unknown' ? null : (0, _path.basename)(prefix) + file.opts.filename.substring(prefix.length);
        var getUniqueTypeName = (0, _createGetUniqueTypeName.default)(cnf.typeNameStrategy);
        var state = {
          getUniqueTypeName: getUniqueTypeName,
          ambiantTypeCastImport: cnf.ambiantTypeCastImport,
          ambiantDepsImport: cnf.ambiantDepsImport,
          ambiantTypeCast: null,
          internalTypes: new Map(),
          externalTypeNames: new Map(),
          exportNames: new Map(),
          functionsWithJsx: new Set()
        };
        path.traverse(_getTypesInfo.default, state);
        var createCreateObjectTypeMetadata = (0, _createCreateCreateObjectTypeMetadata.default)(t);
        var createCreateGenericTypeMetadata = (0, _createCreateCreateGenericTypeMetadata.default)(t, state.externalTypeNames, state.internalTypes, cnf.markGenerics);
        var typeForAnnotation = (0, _createTypeForAnnotation.default)(t, state.externalTypeNames, createCreateObjectTypeMetadata, createCreateGenericTypeMetadata);
        var typeForAnnotations = (0, _createTypeForAnnotations.default)(typeForAnnotation);
        var injectParamTypes = (0, _createInjectParamTypes.default)(t, cnf.injectPrefix, typeForAnnotations, state.functionsWithJsx, filename, cnf.addDisplayName);
        var parentPathInsertAfter = (0, _createParentPathInsertAfter.default)(injectParamTypes);
        var reflectionState = {
          t: t,
          magicTypeCasts: [],
          parentPaths: [],
          onlyExports: cnf.onlyExports,
          exportNames: state.exportNames,
          magicTypeCastExpression: state.ambiantTypeCast ? state.ambiantTypeCast.node.specifiers[0].local.name : ''
        };
        path.traverse(_addReflections.default, reflectionState);
        var replaceMagicTypeCasts = (0, _createReplaceMagicTypeCasts.default)(t, state.externalTypeNames);
        reflectionState.magicTypeCasts.forEach(replaceMagicTypeCasts);
        reflectionState.parentPaths.forEach(parentPathInsertAfter);

        if (state.ambiantTypeCast) {
          state.ambiantTypeCast.remove();
        }
      }
    }
  };
}
//# sourceMappingURL=index.js.map